name: Deploy V2 (Service Repo)
on:
  workflow_call:
    inputs:
      stage:
        required: true
        type: string
        description: 'stage being released (dev,staging,production)'
      service-name:
        required: true
        type: string
        description: 'Proper name for your service i.e OCPP Service, Vehicle Service'
      service-emoji:
        required: true
        type: string
        description: 'An emoji to identify your service by :)'
      service-identifier:
        required: true
        type: string
        description: 'Identifier of the service being released i.e ocpp, vehicle, server, wallet.'
      image-tag:
        required: true
        type: string
        description: 'Docker image tag to deploy'
      slack-message-id:
        required: false
        type: string
        description: 'Existing Slack message ID to update'
      helm-values-path:
        required: false
        type: string
        description: 'Path to helm values directory (default: helm/{service-identifier}/{stage}/app)'
      repository-name:
        required: false
        type: string
        description: 'Repository name override (default: service-{service-identifier})'
      argocd-server:
        required: false
        type: string
        description: 'ArgoCD server URL (e.g., argocd.monta.app) for deployment monitoring'
    secrets:
      MANIFEST_REPO_PAT:
        required: true
        description: 'GitHub personal access token'
      SLACK_APP_TOKEN:
        required: true
        description: 'Slack app token'
      ARGOCD_TOKEN:
        required: false
        description: 'ArgoCD authentication token (required if auto-sync is enabled)'
    outputs:
      slack-message-id:
        description: 'Slack message ID for subsequent updates'
        value: ${{ jobs.deploy.outputs.slack-message-id }}
      stage:
        description: 'Stage this was deployed to (dev,staging,production)'
        value: ${{ jobs.deploy.outputs.stage }}
      docker-image:
        description: 'Docker image with repository'
        value: ${{ jobs.deploy.outputs.docker-image }}
      previous-image-tag:
        description: 'Docker image tag before the release'
        value: ${{ jobs.deploy.outputs.previous-image-tag }}
      image-tag:
        description: 'Docker image tag that was deployed'
        value: ${{ jobs.deploy.outputs.image-tag }}
      deployment-start-time:
        description: 'ISO 8601 timestamp when ArgoCD started the sync (only if auto-sync enabled)'
        value: ${{ jobs.deploy.outputs.deployment-start-time }}
      deployment-end-time:
        description: 'ISO 8601 timestamp when deployment became healthy (only if auto-sync enabled)'
        value: ${{ jobs.deploy.outputs.deployment-end-time }}
      deployment-url:
        description: 'Direct URL to the application in ArgoCD UI (only if auto-sync enabled)'
        value: ${{ jobs.deploy.outputs.deployment-url }}

permissions:
  contents: read

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      slack-message-id: ${{ steps.slack-update.outputs.message-id }}
      stage: ${{ inputs.stage }}
      docker-image: ${{ steps.capture-image-info.outputs.docker-image }}
      previous-image-tag: ${{ steps.capture-image-info.outputs.previous-image-tag }}
      image-tag: ${{ inputs.image-tag }}
      deployment-start-time: ${{ steps.argocd-sync.outputs.deployment-start-time }}
      deployment-end-time: ${{ steps.argocd-sync.outputs.deployment-end-time }}
      deployment-url: ${{ steps.argocd-sync.outputs.deployment-url }}
    steps:
      - name: Update existing slack message
        id: slack-update
        uses: monta-app/slack-notifier-cli-action@main
        with:
          job-type: "deploy"
          job-status: "progress"
          service-name: ${{ inputs.service-name }}
          service-emoji: ${{ inputs.service-emoji }}
          slack-app-token: ${{ secrets.SLACK_APP_TOKEN }}
          slack-channel-id: "C01KL9FUPNK"
          slack-message-id: ${{ inputs.slack-message-id }}
      - name: Check out service repository
        uses: actions/checkout@v4
        with:
          repository: monta-app/${{ inputs.repository-name || format('service-{0}', inputs.service-identifier) }}
          path: 'service-repo'
          token: ${{ secrets.MANIFEST_REPO_PAT }}
      - name: Setup main branch
        working-directory: './service-repo'
        shell: bash
        run: |
          git checkout -B main origin/main
          git branch --set-upstream-to=origin/main main
      - name: Capture current image info
        id: capture-image-info
        shell: bash
        working-directory: ./service-repo/${{ inputs.helm-values-path || format('helm/{0}/{1}/app', inputs.service-identifier, inputs.stage) }}
        run: |
          echo "docker-image=$(yq .kotlin.image.repository values.yaml)" >> "$GITHUB_OUTPUT"
          echo "previous-image-tag=$(yq .kotlin.image.tag values.yaml)" >> "$GITHUB_OUTPUT"
      - name: Update image tag
        shell: bash
        working-directory: ./service-repo/${{ inputs.helm-values-path || format('helm/{0}/{1}/app', inputs.service-identifier, inputs.stage) }}
        run: |
          # Update image tag, revision, and build using yq for proper YAML manipulation
          yq e '.kotlin.image.tag = "${{ inputs.image-tag }}"' -i values.yaml
          yq e '.kotlin.revision = "${{ github.sha }}"' -i values.yaml
          yq e '.kotlin.build = ${{ github.run_number }}' -i values.yaml
      - name: Commit and push with automatic retry
        uses: Artur-Davtyan/git-rebase-push-action@v1
        with:
          repository_path: service-repo
          commit_message: "Bump docker tag for ${{ inputs.service-identifier }} on ${{ inputs.stage }} to ${{ inputs.image-tag }}"
          user_name: "GitHub Action"
          user_email: "action@github.com"
          yq_command: |
            yq e '.kotlin.image.tag = "${{ inputs.image-tag }}"' -i ${{ inputs.helm-values-path || format('helm/{0}/{1}/app', inputs.service-identifier, inputs.stage) }}/values.yaml
            yq e '.kotlin.revision = "${{ github.sha }}"' -i ${{ inputs.helm-values-path || format('helm/{0}/{1}/app', inputs.service-identifier, inputs.stage) }}/values.yaml
            yq e '.kotlin.build = ${{ github.run_number }}' -i ${{ inputs.helm-values-path || format('helm/{0}/{1}/app', inputs.service-identifier, inputs.stage) }}/values.yaml
          max_retries: 10
          retry_delay: 2
      - name: Get manifest commit SHA
        id: manifest-sha
        shell: bash
        working-directory: './service-repo'
        run: |
          MANIFEST_SHA=$(git rev-parse HEAD)
          echo "sha=$MANIFEST_SHA" >> "$GITHUB_OUTPUT"
          echo "Manifest commit SHA: $MANIFEST_SHA"
      - name: Detect ArgoCD auto-sync configuration
        id: detect-autosync
        shell: bash
        working-directory: ./service-repo/${{ inputs.helm-values-path || format('helm/{0}/{1}', inputs.service-identifier, inputs.stage) }}
        env:
          GH_TOKEN: ${{ secrets.MANIFEST_REPO_PAT }}
        run: |
          # Check if config.yaml exists locally and has autoSync configured
          if [ -f "../cluster/config.yaml" ]; then
            if yq e '.autoSync' ../cluster/config.yaml | grep -q -v "null"; then
              echo "enabled=true" >> "$GITHUB_OUTPUT"
              echo "✓ ArgoCD auto-sync is enabled for this application (local config)"
            else
              echo "enabled=false" >> "$GITHUB_OUTPUT"
              echo "⏭️ ArgoCD auto-sync is not configured for this application"
            fi
          else
            echo "⏭️ No local config.yaml found, checking kube-manifests repo..."

            # Fallback: Check kube-manifests repo via GitHub API
            CONFIG_PATH="apps/${{ inputs.service-identifier }}/${{ inputs.stage }}/cluster/config.yaml"

            # Try fetching from kube-manifests repo
            if CONFIG_CONTENT=$(gh api repos/monta-app/kube-manifests/contents/$CONFIG_PATH --jq '.content' 2>/dev/null); then
              # Decode base64 content and check for autoSync
              if echo "$CONFIG_CONTENT" | base64 -d | yq e '.autoSync' - | grep -q -v "null"; then
                echo "enabled=true" >> "$GITHUB_OUTPUT"
                echo "✓ ArgoCD auto-sync is enabled for this application (kube-manifests config)"
              else
                echo "enabled=false" >> "$GITHUB_OUTPUT"
                echo "⏭️ ArgoCD auto-sync is not configured for this application"
              fi
            else
              echo "enabled=false" >> "$GITHUB_OUTPUT"
              echo "⏭️ No config.yaml found in local repo or kube-manifests - ArgoCD auto-sync is not configured"
            fi
          fi
      - name: Check ArgoCD credentials
        id: check-argocd-creds
        shell: bash
        env:
          ARGOCD_SERVER: ${{ inputs.argocd-server }}
          ARGOCD_TOKEN: ${{ secrets.ARGOCD_TOKEN }}
        run: |
          if [ -n "$ARGOCD_SERVER" ] && [ -n "$ARGOCD_TOKEN" ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
          fi
      - name: Log ArgoCD sync skip
        if: ${{ steps.detect-autosync.outputs.enabled == 'false' || steps.check-argocd-creds.outputs.available == 'false' }}
        shell: bash
        run: |
          if [ "${{ steps.detect-autosync.outputs.enabled }}" = "false" ]; then
            echo "⏭️ Skipping ArgoCD sync monitoring - auto-sync is not configured for this application"
          else
            echo "⏭️ Skipping ArgoCD sync monitoring - argocd-server input or ARGOCD_TOKEN secret not provided"
          fi
      - name: Wait for ArgoCD sync
        if: ${{ steps.detect-autosync.outputs.enabled == 'true' && steps.check-argocd-creds.outputs.available == 'true' }}
        id: argocd-sync
        uses: monta-app/github-workflows/.github/actions/argocd-wait-sync@main
        with:
          server: ${{ inputs.argocd-server }}
          app-name: ${{ inputs.service-identifier }}-${{ inputs.stage }}
          auth-token: ${{ secrets.ARGOCD_TOKEN }}
          revision: ${{ steps.manifest-sha.outputs.sha }}
          timeout: 300
          manifest-repo: monta-app/${{ inputs.repository-name || format('service-{0}', inputs.service-identifier) }}
          github-token: ${{ secrets.MANIFEST_REPO_PAT }}
      - name: Fix permissions for cleanup
        if: always()
        shell: bash
        run: |
          # Docker action creates root-owned files; fix permissions for cleanup
          sudo chown -R "$USER:$USER" service-repo || true
      - name: Publish result message to slack
        if: always()
        uses: monta-app/slack-notifier-cli-action@main
        with:
          job-type: "deploy"
          job-status: ${{ job.status }}
          service-name: ${{ inputs.service-name }}
          service-emoji: ${{ inputs.service-emoji }}
          slack-app-token: ${{ secrets.SLACK_APP_TOKEN }}
          slack-channel-id: "C01KL9FUPNK"
          slack-message-id: ${{ inputs.slack-message-id }}
