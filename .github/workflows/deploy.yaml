name: Deploy
on:
  workflow_call:
    inputs:
      service-name:
        required: false
        type: string
        description: 'Proper name for your service i.e OCPP Service, Vehicle Service'
      service-emoji:
        required: false
        type: string
        description: 'An emoji to identify your service by :)'
      service-identifier:
        required: true
        type: string
        description: 'Identifier of the service being released i.e ocpp, vehicle, server, wallet.'
      gradle-module:
        required: false
        type: string
        description: 'Name of the gradle module being tested'
      region:
        required: true
        type: string
        default: 'eu-west-1'
        description: 'AWS region'
      stage:
        required: true
        type: string
        description: 'stage being released (dev,staging,production)'
      docker-file-name:
        required: false
        type: string
        description: Name of the docker file to be built
        default: "Dockerfile"
      java-distribution:
        required: false
        type: string
        default: "corretto"
      java-version:
        required: false
        type: string
        default: "17"
      java-docker-version:
        required: false
        type: string
        default: "17.0.8"
      slack-channel-id:
        required: false
        type: string
        description: 'ID of slack channel to notify with build status. Default value is the "deployment" channel, only override in special cases.'
        default: "C01KL9FUPNK"
      upload-open-api:
        required: false
        type: boolean
        default: false
        description: 'Upload open api specification to the kube manifests repository'
      arm-build:
        required: false
        type: boolean
        default: false
        description: 'Build both an arm64 image in addition to the x64 image'
      self-hosted:
        required: false
        type: boolean
        default: false
        description: 'Builds a x64 image, on a self-hosted runner x64 machine'
      push-to-manifests:
        required: false
        type: boolean
        default: true
        description: 'If false, will use ArgoCD Updater instead of pushing to kube-manifests'
    secrets:
      GHL_USERNAME:
        required: true
        description: 'Github Username (Gradle plugin)'
      GHL_PASSWORD:
        required: true
        description: 'Github Password (Gradle plugin)'
      AWS_ACCOUNT_ID:
        required: false
        description: 'AWS account id'
      AWS_ACCESS_KEY_ID:
        required: false
        description: 'AWS access key id'
      AWS_SECRET_ACCESS_KEY:
        required: false
        description: 'AWS secret access key'
      MANIFEST_REPO_PAT:
        required: true
        description: 'GitHub personal access token'
      SLACK_APP_TOKEN:
        required: true
        description: 'Slack app token'
      ARGOCD_TOKEN:
        required: false # REQUIRED WHEN USING `upload-open-api`!!!
        description: 'ArgoCD token - should be set to ARGOCD_TOKEN_STAGING / ARGOCD_TOKEN_PRODUCTION'
permissions:
  id-token: write # This is required for requesting the JWT
  contents: read
  actions: read # This is required for 8398a7/action-slack

jobs:
  # needed in order for test and build to start independently while updating the same slack message
  init:
    name: Sending first Slack message
    runs-on: ubuntu-latest
    env:
      argocd-token: ${{ secrets.ARGOCD_TOKEN }}
    timeout-minutes: 5
    outputs:
      slack-message-id: ${{ steps.publish-slack.outputs.slack-message-id }}
      runners: ${{ toJSON(steps.*.outputs.runner) }}
      service-cluster: ${{ steps.get-manifest-info.outputs.cluster }}
      service-namespace: ${{ steps.get-manifest-info.outputs.namespace }}
      service-name: ${{ steps.get-manifest-info.outputs.service-name }}
      argocd-server: ${{ steps.set-argocd-server.outputs.argocd-hostname }}
    steps:
      - name: Publish progress message to slack
        uses: monta-app/slack-notifier-cli-action@main
        id: publish-slack
        with:
          job-type: "test"
          job-status: "progress"
          service-name: ${{ inputs.service-name }}
          service-emoji: ${{ inputs.service-emoji }}
          slack-app-token: ${{ secrets.SLACK_APP_TOKEN }}
          slack-channel-id: ${{ inputs.slack-channel-id }}
      # calculates whether should run also on arm
      - id: hosted-x64
        if: ${{ ! inputs.self-hosted }}
        run: echo "runner=ubuntu-latest" >> $GITHUB_OUTPUT
      - id: self-hosted-x64
        if: ${{ inputs.self-hosted }}
        run: echo "runner=self-hosted-x64" >> $GITHUB_OUTPUT
      - id: self-hosted-arm64
        if: ${{ inputs.arm-build }}
        run: echo "runner=self-hosted-arm64" >> $GITHUB_OUTPUT
      - id: verify-argocd-token
        if: ${{ ! inputs.push-to-manifests }}
        shell: bash
        run: |
          if [ "${{ secrets.ARGOCD_TOKEN }}" == '' ]; then
            echo "::error::MUST INPUT ARGOCD_TOKEN SECRET"
            echo "ARGOCD_TOKEN_STAGING / ARGOCD_TOKEN_PRODUCTION"
            exit 1
          fi
      - id: set-argocd-server
        if: ${{ env.argocd-token != '' }}
        env:
          STAGE: ${{ inputs.stage }}
        run: |
          if [[ $STAGE =~ dev|staging ]]; then
            ARGOCD_HOSTNAME="argocd.staging.monta.app"
          else
            ARGOCD_HOSTNAME="argocd.monta.app"
          fi
          echo "argocd-hostname=$ARGOCD_HOSTNAME" >> "$GITHUB_OUTPUT"
      - name: Get manifest info
        id: get-manifest-info
        if: ${{ inputs.upload-open-api }}
        shell: bash
        env:
          SERVICE_IDENTIFIER: ${{ inputs.service-identifier }}
          STAGE: ${{ inputs.stage }}
          ARGOCD_TOKEN: ${{ secrets.ARGOCD_TOKEN }}
          ARGOCD_SERVER: ${{ steps.set-argocd-server.outputs.argocd-hostname }}
        run: |
          if [ "${{ secrets.ARGOCD_TOKEN }}" == '' ]; then
            echo "::error::MUST INPUT ARGOCD_TOKEN SECRET"
            echo "ARGOCD_TOKEN_STAGING / ARGOCD_TOKEN_PRODUCTION"
            exit 1
          fi
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo chmod +x argocd
          K8S_CLUSTER=$(./argocd --grpc-web --auth-token $ARGOCD_TOKEN --server $ARGOCD_SERVER app get argocd/${{ inputs.service-identifier }}-${{ inputs.stage }} -o yaml | yq '.spec.destination.name')
          if [ $K8S_CLUSTER == "main-prod" ]; then
            export K8S_CLUSTER="main-production"
          fi
          echo "cluster=$K8S_CLUSTER" >> "$GITHUB_OUTPUT"
          K8S_NAMESPACE=$(./argocd --grpc-web --auth-token $ARGOCD_TOKEN --server $ARGOCD_SERVER app get argocd/${{ inputs.service-identifier }}-${{ inputs.stage }} -o yaml | yq '.spec.destination.namespace')
          echo "namespace=$K8S_NAMESPACE" >> "$GITHUB_OUTPUT"
          SERVICE_NAME=$(./argocd --grpc-web --auth-token $ARGOCD_TOKEN --server $ARGOCD_SERVER app manifests argocd/${{ inputs.service-identifier }}-${{ inputs.stage }} | yq 'select(di == 1) | .metadata.labels."app.kubernetes.io/name"')

          if [ $SERVICE_NAME = "null" ]; then
            SERVICE_NAME=$(./argocd --grpc-web --auth-token $ARGOCD_TOKEN --server $ARGOCD_SERVER app manifests argocd/${{ inputs.service-identifier }}-${{ inputs.stage }} | yq 'select(di == 1) | .metadata.labels."app"')
          fi

          echo "service-name=$SERVICE_NAME" >> "$GITHUB_OUTPUT"

  test:
    name: Test
    needs: init
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Download curl
        id: download-curl
        shell: bash
        run: |
          sudo apt update
          sudo apt install -y curl
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: ${{ inputs.java-distribution }}
          java-version: ${{ inputs.java-version }}
          cache: 'gradle'
      - name: Test project
        env:
          GHL_USERNAME: ${{ secrets.GHL_USERNAME }}
          GHL_PASSWORD: ${{ secrets.GHL_PASSWORD }}
          GRADLE_MODULE: ${{ inputs.gradle-module }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo test
        shell: bash

  update-open-api-spec:
    if: ${{ inputs.upload-open-api }}
    name: Update OpenAPI Spec
    needs: [ init, test ]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: ${{ inputs.java-distribution }}
          java-version: ${{ inputs.java-version }}
          cache: 'gradle'
      - name: Install LinkerD CLI
        shell: bash
        run: |
          curl --proto '=https' --tlsv1.2 -sSfL https://run.linkerd.io/install | sh
      - name: Install kubectl CLI
        shell: bash
        run: |
          curl -LO https://dl.k8s.io/release/v1.28.4/bin/linux/amd64/kubectl
          sudo chmod +x kubectl
      - name: Install Teleport
        uses: teleport-actions/setup@v1
        with:
          version: 14.1.5
      - name: Update Path with LinkerD CLI
        shell: bash
        run: |
          echo "/home/runner/.linkerd2/bin" >> $GITHUB_PATH
      - name: Discover build properties
        shell: bash
        env:
          GHL_USERNAME: ${{ secrets.GHL_USERNAME }}
          GHL_PASSWORD: ${{ secrets.GHL_PASSWORD }}
          GRADLE_MODULE: ${{ inputs.gradle-module }}
        run: |
          GRADLE_TASK=$(./gradlew ${GRADLE_MODULE}:tasks --all | grep -E '(kaptKotlin|kspKotlin)' | head -n1)
          if [ "$GRADLE_TASK" = "kaptKotlin" ]; then
            OUTPUT_DIR="build/tmp/kapt3/classes/main/META-INF/swagger"
          elif [ "$GRADLE_TASK" = "kspKotlin" ]; then
            OUTPUT_DIR="build/generated/ksp/main/resources/META-INF/swagger"
          fi

          echo "GRADLE_TASK=${GRADLE_MODULE}:${GRADLE_TASK}" >> "$GITHUB_ENV"
          echo "OPENAPI_OUTPUT_DIR=${OUTPUT_DIR}" >> "$GITHUB_ENV"
      - name: Build Open API Spec
        shell: bash
        env:
          GHL_USERNAME: ${{ secrets.GHL_USERNAME }}
          GHL_PASSWORD: ${{ secrets.GHL_PASSWORD }}
          GRADLE_MODULE: ${{ inputs.gradle-module }}
        run: |
          ./gradlew $GRADLE_TASK
      # - name: Configure AWS credentials
      #   uses: aws-actions/configure-aws-credentials@v1
      #   with:
      #     aws-access-key-id: ${{ secrets.TECHDOCS_AWS_ACCESS_KEY_ID }}
      #     aws-secret-access-key: ${{ secrets.TECHDOCS_AWS_ACCESS_KEY_ID }}
      #     aws-region: 'eu-west-1'
      - name: Upload Open API Spec to S3 backstage bucket
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.TECHDOCS_AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.TECHDOCS_AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: 'eu-west-1'
        run: |
          # Find the generated spec
          YML_FILE=$(find . -type f -name '*.yml' \
            | grep "$OPENAPI_OUTPUT_DIR" \
            | head -n1)

          # Check if a .yml file was found and display the result or an error message
          if [ -z "${YML_FILE}" ]; then
              echo "No .yml file found in ${TARGET_DIR}."
              exit 1
          fi 
          # Print the yml file
          echo "Building catalog file from:${YML_FILE}"
          spec_file=${YML_FILE}
          service_name=${{ inputs.service-identifier }}
          output_file_path="$OPENAPI_OUTPUT_DIR/catalog_${service_name}_api.yaml"

          
          spec=$(cat $spec_file)
          # Build the final spec file
          echo "Saving catalog file to ${output_file_path}"
          cat << EndOfMessage > ${output_file_path}
          apiVersion: backstage.io/v1alpha1
          kind: API
          metadata:
            name: ${service_name}
          spec:
            type: openapi
            lifecycle: production
            owner: sre
            system: Platform
            definition: |
          $(cat $spec_file | sed 's/^/    /')
          EndOfMessage

          echo "Uploading catalog file from:${output_file_path}"
          aws s3 cp ${output_file_path} s3://monta-tech-docs/api/
          echo "Upload complete."

      - name: Authorize against Teleport
        uses: teleport-actions/auth-k8s@v2
        with:
          proxy: 'teleport.monta.app:443'
          token: github-actions
          kubernetes-cluster: ${{ needs.init.outputs.service-cluster }}
      - name: Create service profile
        id: create-service-profile
        shell: bash
        env:
          GRADLE_MODULE: ${{ inputs.gradle-module }}
          K8S_NAMESPACE: ${{ needs.init.outputs.service-namespace }}
          SERVICE_NAME: ${{ needs.init.outputs.service-name }}
        run: |
          # Find the generated spec
          YML_FILE=$(find . -type f -name '*.yml' \
            | grep "$OPENAPI_OUTPUT_DIR" \
            | head -n1)

          # Check if a .yml file was found and display the result or an error message
          if [ -z "${YML_FILE}" ]; then
              echo "No .yml file found in ${TARGET_DIR}."
              exit 1
          fi

          linkerd profile --ignore-cluster -n $K8S_NAMESPACE --open-api $YML_FILE $SERVICE_NAME >> service-profile.yaml
          
          cat <<EOB >> clean-service-profiles.sh
          #!/bin/bash
          yq service-profile.yaml
          yq service-profile.yaml | yq 'del(.spec.routes[].responseClasses)' service-profile.yaml > service-profile-new.yaml
          cat <<EOT >> service-profile-new.yaml
              - condition:
                  method: POST
                name: POST [Default]
              - condition:
                  method: GET
                name: GET [Default]
              - condition:
                  method: PATCH
                name: PATCH [Default]
              - condition:
                  method: PUT
                name: PUT [Default]
              - condition:
                  method: HEAD
                name: HEAD [Default]
              - condition:
                  method: OPTIONS
                name: OPTIONS [Default]
          EOT
          yq service-profile-new.yaml
          EOB

          bash clean-service-profiles.sh
          
          kubectl -n $K8S_NAMESPACE apply -f service-profile-new.yaml